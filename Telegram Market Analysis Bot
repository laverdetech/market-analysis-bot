import os
import telegram
from telegram.ext import Updater, CommandHandler, MessageHandler, Filters
import requests
import json
from datetime import datetime
import pandas as pd
import logging
import asyncio
from telegram import Update, ParseMode
from telegram.ext import ApplicationBuilder, ContextTypes, CommandHandler

# Konfiguraƒçn√© kon≈°tanty
TELEGRAM_TOKEN = "7375227916:AAGq223FfK-2HMAIGbLrfEq4WfUivGvSqj8"
ALPHA_VANTAGE_API_KEY = "M35WFJN1LJ5MZ9DF"
CHECK_INTERVAL = 3600  # kontrola ka≈æd√∫ hodinu
PRICE_CHANGE_THRESHOLD = 0.01  # 1% zmena pre notifik√°cie

# Nastavenie loggingu
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    filename='market_bot.log'  # Pridan√© logovanie do s√∫boru
)
logger = logging.getLogger(__name__)

class MarketAnalysisBot:
    def __init__(self):
        self.previous_gold_price = None
        self.previous_silver_price = None
        self.subscribed_users = set()  # Mno≈æina pre sledovanie prihl√°sen√Ωch u≈æ√≠vateƒæov
        
    async def get_metal_price(self, metal):
        """Z√≠ska aktu√°lnu cenu kovu (XAU alebo XAG)"""
        url = f"https://www.alphavantage.co/query?function=CURRENCY_EXCHANGE_RATE&from_currency={metal}&to_currency=USD&apikey={ALPHA_VANTAGE_API_KEY}"
        
        try:
            response = requests.get(url)
            data = response.json()
            if "Realtime Currency Exchange Rate" in data:
                price = float(data["Realtime Currency Exchange Rate"]["5. Exchange Rate"])
                return price
            else:
                logger.error(f"Neplatn√° odpoveƒè API pre {metal}: {data}")
                return None
        except Exception as e:
            logger.error(f"Chyba pri z√≠skavan√≠ ceny {metal}: {str(e)}")
            return None

    async def get_market_news(self):
        """Z√≠ska najnov≈°ie spr√°vy z trhu"""
        url = f'https://www.alphavantage.co/query?function=NEWS_SENTIMENT&tickers=GOLD,SILVER&apikey={ALPHA_VANTAGE_API_KEY}'
        
        try:
            response = requests.get(url)
            data = response.json()
            return data.get('feed', [])[:5]  # Vracia prv√Ωch 5 spr√°v
        except Exception as e:
            logger.error(f"Chyba pri z√≠skavan√≠ spr√°v: {str(e)}")
            return []

    async def get_economic_indicators(self):
        """Z√≠ska ekonomick√© indik√°tory"""
        indicators = {}
        
        # Z√≠skanie infl√°cie
        try:
            inflation_url = f'https://www.alphavantage.co/query?function=INFLATION&apikey={ALPHA_VANTAGE_API_KEY}'
            response = requests.get(inflation_url)
            data = response.json()
            indicators['inflation'] = data['data'][0]['value']
        except Exception as e:
            logger.error(f"Chyba pri z√≠skavan√≠ infl√°cie: {str(e)}")
            
        # Z√≠skanie nezamestnanosti
        try:
            unemployment_url = f'https://www.alphavantage.co/query?function=UNEMPLOYMENT&apikey={ALPHA_VANTAGE_API_KEY}'
            response = requests.get(unemployment_url)
            data = response.json()
            indicators['unemployment'] = data['data'][0]['value']
        except Exception as e:
            logger.error(f"Chyba pri z√≠skavan√≠ nezamestnanosti: {str(e)}")
            
        # Z√≠skanie NFP
        try:
            nfp_url = f'https://www.alphavantage.co/query?function=NONFARM_PAYROLL&apikey={ALPHA_VANTAGE_API_KEY}'
            response = requests.get(nfp_url)
            data = response.json()
            indicators['nfp'] = data['data'][0]['value']
        except Exception as e:
            logger.error(f"Chyba pri z√≠skavan√≠ NFP: {str(e)}")
            
        return indicators

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Spracuje pr√≠kaz /start"""
        user_id = update.message.from_user.id
        self.subscribed_users.add(user_id)
        
        welcome_message = """
        üëã Vitajte v Market Analysis Bot!

        Dostupn√© pr√≠kazy:
        /prices - Zobraz√≠ aktu√°lne ceny zlata a striebra
        /news - Zobraz√≠ najnov≈°ie spr√°vy z trhu
        /indicators - Zobraz√≠ ekonomick√© indik√°tory
        /analyze - Komplexn√° anal√Ωza trhu
        /subscribe - Prihl√°si≈• sa na notifik√°cie
        /unsubscribe - Odhl√°si≈• sa z notifik√°ci√≠
        /help - Zobraz√≠ t√∫to n√°povedu
        
        Bot automaticky sleduje v√Ωznamn√© zmeny na trhu a po≈°le v√°m notifik√°ciu.
        """
        await update.message.reply_text(welcome_message, parse_mode=ParseMode.MARKDOWN)

    async def help(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Zobraz√≠ n√°povedu"""
        await self.start(update, context)

    async def subscribe(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Prihl√°si u≈æ√≠vateƒæa na notifik√°cie"""
        user_id = update.message.from_user.id
        self.subscribed_users.add(user_id)
        await update.message.reply_text("‚úÖ √öspe≈°ne ste sa prihl√°sili na notifik√°cie o zmen√°ch na trhu!")

    async def unsubscribe(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Odhl√°si u≈æ√≠vateƒæa z notifik√°ci√≠"""
        user_id = update.message.from_user.id
        self.subscribed_users.discard(user_id)
        await update.message.reply_text("‚ùå Boli ste odhl√°sen√≠ z notifik√°ci√≠ o zmen√°ch na trhu.")

    async def prices(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Spracuje pr√≠kaz /prices"""
        gold_price = await self.get_metal_price('XAU')
        silver_price = await self.get_metal_price('XAG')
        
        if gold_price is None or silver_price is None:
            await update.message.reply_text("‚ö†Ô∏è Moment√°lne nie je mo≈æn√© z√≠ska≈• ceny. Sk√∫ste to pros√≠m nesk√¥r.")
            return
        
        message = f"""
        üìä Aktu√°lne ceny drah√Ωch kovov:

        ü•á Zlato (XAUUSD): ${gold_price:.2f}
        ü•à Striebro (XAGUSD): ${silver_price:.2f}
        
        ƒåasov√° peƒçiatka: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
        """
        await update.message.reply_text(message)

    async def news(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Spracuje pr√≠kaz /news"""
        news = await self.get_market_news()
        
        if not news:
            await update.message.reply_text("‚ö†Ô∏è Moment√°lne nie s√∫ k dispoz√≠cii ≈æiadne spr√°vy.")
            return

        message = "üì∞ Najnov≈°ie spr√°vy z trhu:\n\n"
        for item in news:
            message += f"üìå {item['title']}\n"
            sentiment_score = float(item['overall_sentiment_score'])
            sentiment_emoji = "üü¢" if sentiment_score > 0.2 else "üî¥" if sentiment_score < -0.2 else "‚ö™"
            message += f"   Sentiment: {sentiment_emoji} {sentiment_score:.2f}\n"
            message += f"   {item['url']}\n\n"
        
        await update.message.reply_text(message)

    async def indicators(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Spracuje pr√≠kaz /indicators"""
        indicators = await self.get_economic_indicators()
        
        message = """
        üìà Ekonomick√© indik√°tory:

        Infl√°cia: {}%
        Nezamestnanos≈•: {}%
        NFP: {} tis√≠c
        """.format(
            indicators.get('inflation', 'N/A'),
            indicators.get('unemployment', 'N/A'),
            indicators.get('nfp', 'N/A')
        )
        
        await update.message.reply_text(message)

    async def analyze(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Spracuje pr√≠kaz /analyze - komplexn√° anal√Ωza trhu"""
        gold_price = await self.get_metal_price('XAU')
        silver_price = await self.get_metal_price('XAG')
        indicators = await self.get_economic_indicators()
        news = await self.get_market_news()
        
        gold_silver_ratio = gold_price / silver_price if gold_price and silver_price else None
        
        analysis = f"""
        üîç Komplexn√° anal√Ωza trhu:

        üí∞ Ceny drah√Ωch kovov:
        ü•á Zlato: ${gold_price:.2f}
        ü•à Striebro: ${silver_price:.2f}
        üìä Pomer Zlato/Striebro: {gold_silver_ratio:.2f}

        üìà Ekonomick√© indik√°tory:
        üìà Infl√°cia: {indicators.get('inflation', 'N/A')}%
        üë• Nezamestnanos≈•: {indicators.get('unemployment', 'N/A')}%
        üë®‚Äçüíº NFP: {indicators.get('nfp', 'N/A')} tis√≠c

        üì∞ Kƒæ√∫ƒçov√© spr√°vy a sentiment:
        """
        
        for item in news[:3]:
            sentiment_score = float(item['overall_sentiment_score'])
            sentiment_emoji = "üü¢" if sentiment_score > 0.2 else "üî¥" if sentiment_score < -0.2 else "‚ö™"
            analysis += f"\n‚Ä¢ {item['title']}"
            analysis += f"\n  Sentiment: {sentiment_emoji} {sentiment_score:.2f}"
        
        analysis += "\n\nüí° Odpor√∫ƒçania:"
        if gold_silver_ratio:
            if gold_silver_ratio > 80:
                analysis += "\n‚Ä¢ Vysok√Ω pomer Zlato/Striebro naznaƒçuje mo≈æn√© podhodnotenie striebra"
            elif gold_silver_ratio < 60:
                analysis += "\n‚Ä¢ N√≠zky pomer Zlato/Striebro naznaƒçuje mo≈æn√© podhodnotenie zlata"
        
        await update.message.reply_text(analysis)

    async def check_market_changes(self, context: ContextTypes.DEFAULT_TYPE):
        """Kontroluje v√Ωznamn√© zmeny na trhu a posiela notifik√°cie"""
        gold_price = await self.get_metal_price('XAU')
        silver_price = await self.get_metal_price('XAG')

        if not gold_price or not silver_price:
            logger.error("Nepodarilo sa z√≠ska≈• ceny kovov pre kontrolu zmien")
            return

        # Kontrola zmien v cene zlata
        if self.previous_gold_price and abs((gold_price - self.previous_gold_price) / self.previous_gold_price) > PRICE_CHANGE_THRESHOLD:
            message = f"""
            ‚ö†Ô∏è V√Ωznamn√° zmena ceny zlata:
            Nov√° cena: ${gold_price:.2f}
            Zmena: {((gold_price - self.previous_gold_price) / self.previous_gold_price) * 100:.2f}%
            """
            for user_id in self.subscribed_users:
                try:
                    await context.bot.send_message(chat_id=user_id, text=message)
                except Exception as e:
                    logger.error(f"Nepodarilo sa posla≈• notifik√°ciu u≈æ√≠vateƒæovi {user_id}: {str(e)}")

        # Kontrola zmien v cene striebra
        if self.previous_silver_price and abs((silver_price - self.previous_silver_price) / self.previous_silver_price) > PRICE_CHANGE_THRESHOLD:
            message = f"""
            ‚ö†Ô∏è V√Ωznamn√° zmena ceny striebra:
            Nov√° cena: ${silver_price:.2f}
            Zmena: {((silver_price - self.previous_silver_price) / self.previous_silver_price) * 100:.2f}%
            """
            for user_id in self.subscribed_users:
                try:
                    await context.bot.send_message(chat_id=user_id, text=message)
                except Exception as e:
                    logger.error(f"Nepodarilo sa posla≈• notifik√°ciu u≈æ√≠vateƒæovi {user_id}: {str(e)}")

        self.previous_gold_price = gold_price
        self.previous_silver_price = silver_price

async def run_periodic_checks(application):
    """Sp√∫≈°≈•a periodick√© kontroly zmien na trhu"""
    while True:
        await asyncio.sleep(CHECK_INTERVAL)
        bot = MarketAnalysisBot()
        await bot.check_market_changes(application)

def main():
    # Vytvorenie bota
    bot = MarketAnalysisBot()
    application = ApplicationBuilder().token(TELEGRAM_TOKEN).build()

    # Pridanie handlerov pre pr√≠kazy
    application.add_handler(CommandHandler("start", bot.start))
    application.add_handler(CommandHandler("help", bot.help))
    application.add_handler(CommandHandler("prices", bot.prices))
    application.add_handler(CommandHandler("news", bot.news))
    application.add_handler(CommandHandler("indicators", bot.indicators))
    application.add_handler(CommandHandler("analyze", bot.analyze))
    application.add_handler(CommandHandler("subscribe", bot.subscribe))
    application.add_handler(CommandHandler("unsubscribe", bot.unsubscribe))

    # Spustenie periodick√Ωch kontrol v samostatnom vl√°kne
    asyncio.create_task(run_periodic_checks(application))

    # Spustenie bota
    application.run_polling()

if __name__ == '__main__':
    main()
